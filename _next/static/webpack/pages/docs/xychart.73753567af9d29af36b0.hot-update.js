webpackHotUpdate_N_E("pages/docs/xychart",{

/***/ "../../node_modules/raw-loader/dist/cjs.js!../visx-xychart/Readme.md":
/*!**********************************************************************************************************!*\
  !*** /Users/christopher-williams/dev/visx/node_modules/raw-loader/dist/cjs.js!../visx-xychart/Readme.md ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"# @visx/xychart\\n\\nIn contrast to other `visx` packages which are low-level, this package seeks to abstract some of the\\ncomplexity of common visualization engineering, and exposes a **high-level** x,y (cartesian\\ncoordinate) chart API. However, it is implemented using modularized `React.context` layers for\\ntheme, canvas dimensions, x/y/color scales, data, events, and tooltips which allows for more\\nexpressivity and advanced use cases.\\n\\nOut of the box it supports the following:\\n\\n- many common `<*Series />` types (animated or not) such as lines, bars, etc. (can be easily\\n  extended to support more in the future)\\n- `<Axis />` (animated or not)\\n- `<Grid />` (animated or not)\\n- `<Annotation />` (animated or not)\\n- `<Tooltip />`\\n- `theme`ing\\n\\nSee the comprehensive API below for more details.\\n\\n<hr />\\n\\n## Basic usage\\n\\nThe following illustrates basic usage for an animated line chart with a bottom `Axis`, `Grid`, and\\n`Tooltip`, try it on codesandbox [here](todo, simplify code below):\\n\\n```tsx\\nimport { AnimatedAxis, AnimatedGrid, AnimatedLineSeries, XYChart } from '@visx/xychart';\\n\\nconst data1 = [\\n  { x: '2020-01-01', y: 50 },\\n  { x: '2020-01-02', y: 10 },\\n  { x: '2020-01-03', y: 20 },\\n  { x: '2020-01-04', y: 10 },\\n  { x: '2020-01-05', y: 0 },\\n];\\n\\nconst data2 = [\\n  { x: '2020-01-01', y: 30 },\\n  { x: '2020-01-02', y: 40 },\\n  { x: '2020-01-03', y: 80 },\\n  { x: '2020-01-04', y: 70 },\\n  { x: '2020-01-05', y: 20 },\\n];\\n\\nconst xAccessor = d => d.x;\\nconst yAccessor = d => d.y;\\n\\nconst render = () => (\\n  <XYChart height={300} xScale={{ type: 'band' }} yScale={{ type: 'linear' }}>\\n    <AnimatedAxis orientation=\\\"bottom\\\" />\\n    <AnimatedGrid columns={false} numTicks={4} />\\n    <AnimatedLineSeries dataKey=\\\"Line 1\\\" data={data1} xAccessor={xAccessor} yAccessor={yAccessor} />\\n    <AnimatedLineSeries dataKey=\\\"Line 2\\\" data={data2} xAccessor={xAccessor} yAccessor={yAccessor} />\\n    <Tooltip\\n      snapTooltipToDatumX\\n      snapTooltipToDatumY\\n      showVerticalCrosshair\\n      showSeriesGlyphs\\n      renderTooltip={({ tooltipData, colorScale }) => (\\n        <div>\\n          <div style={{ color: colorScale(tooltipData.nearestDatum.key) }}>\\n            {tooltipData.nearestDatum.key || 'No key'}\\n          </div>\\n          {tooltipData.nearestDatum.datum.x || 'No date'}\\n          {', '}\\n          {tooltipData.nearestDatum.datum.y || 'No value'}\\n        </div>\\n      )}\\n    />\\n  </XYChart>\\n);\\n```\\n\\nExpand sections for more, or explore the detailed API below.\\n\\n<details>\\n\\n<summary>Series types</summary>\\n\\n### Series types\\n\\nThe following `Series` types are currently supported and we are happy to review or consider\\nadditional Series types in the future.\\n\\n| Component name        | Description                                                                                      | Usage                                                |\\n| --------------------- | ------------------------------------------------------------------------------------------------ | ---------------------------------------------------- |\\n| (Animated)AreaSeries  | Connect data points with a `<path />`, with a color fill to the zero baseline                    | `<AreaSeries />`                                     |\\n| (Animated)BarSeries   | Render a `<rect />` for each data point                                                          | `<BarSeries />`                                      |\\n| (Animated)BarGroup    | Group multiple child `<BarSeries />` values together                                             | `<BarGroup><BarSeries /><BarSeries />...</BarGroup>` |\\n| (Animated)BarStack    | Stack multiple child `<BarSeries />` values together                                             | `<BarStack><BarSeries /><BarSeries />...</BarStack>` |  |\\n| (Animated)GlyphSeries | Render a `Glyph` (any shape, defaults to `<circle />`) for each data point, e.g., a scatter plot | `<GlyphSeries renderGlyph={() => ...} />`            |\\n| (Animated)LineSeries  | Connect data points with a `<path>`                                                              | `<GlyphSeries />`                                    |\\n\\nAll `Series` have animated and non-animated variants to give you more control over your bundle size,\\nsupport missing (`null`) data, and can be rendered vertically or horizontally.\\n\\n</details>\\n\\n<details>\\n\\n<summary>Theming</summary>\\n\\n### Theming\\n\\nDefault `lightTheme` and `darkTheme` themes are exported from `@visx/xychart` and the utility\\n`buildChartTheme` is exported to support easy creation of custom themes.\\n\\n```ts\\nimport { buildTheme, XYChart } from '@visx/xychart';\\nimport { TextProps as SVGTextProps } from '@visx/text/lib/Text'; // just for types\\n\\nconst customTheme = buildTheme({\\n  // colors\\n  backgroundColor: string; // used by Tooltip, Annotation\\n  colors: string[]; // categorical colors, mapped to series via `dataKey`s\\n\\n  // labels\\n  svgLabelBig?: SVGTextProps;\\n  svgLabelSmall?: SVGTextProps;\\n  htmlLabel?: HTMLTextStyles;\\n\\n  // lines\\n  xAxisLineStyles?: LineStyles;\\n  yAxisLineStyles?: LineStyles;\\n  xTickLineStyles?: LineStyles;\\n  yTickLineStyles?: LineStyles;\\n  tickLength: number;\\n\\n  // grid\\n  gridColor: string;\\n  gridColorDark: string; // used for axis baseline if x/yxAxisLineStyles not set\\n  gridStyles?: CSSProperties;\\n});\\n\\n() => <XYChart theme={customTheme} />\\n```\\n\\n</details>\\n\\n<details>\\n\\n<summary>Tooltips</summary>\\n\\n### Tooltips\\n\\n`@visx/tooltip` `Tooltip`s are integrated into `@visx/xychart`, and should be rendered as a child of\\n`XYChart` (or a child where `TooltipContext` is provided).\\n\\n**`Tooltip` positioning** is handled by the `Tooltip` itself, based on `TooltipContext`. `Tooltip`\\nis rendered inside a `Portal`, avoiding clipping by parent DOM elements with higher z-index\\ncontexts. See the API below for a full list of `props` to support additional behavior, such as\\nsnapping to data point positions and rendering cross-hairs.\\n\\n**`Tooltip` content** is controlled by the specified `prop.renderTooltip` which has access to:\\n\\n- `tooltipData.nearestDatum` ‚Äì the globally closest `Datum`, **across all** `Series`'s `dataKey`s\\n- `tooltipData.datumByKey` ‚Äì the closest `Datum` **for each** `Series`'s `dataKey`; this enables\\n  \\\"shared tooltips\\\" where you can render the nearest data point for each `Series`.\\n- a shared `colorScale` which maps `Series`'s `dataKey`s to `theme` colors\\n\\n</details>\\n\\n<details>\\n\\n<summary>Event handlers</summary>\\n\\n### Event handlers\\n\\nThe following `PointerEvent`s (handling both `MouseEvent`s and `TouchEvent`s) are currently\\nsupported. They may be set on individual `Series` components (e.g.,\\n`<BarSeries onPointerMove={() => ...} />`), or at the chart level (e.g.,\\n`<XYChart onPointerMove={() => {}} />`) in which case they are invoked once for _every_ `*Series`.\\nTo **disable** event emitting for any `Series` set `<*Series enableEvents=false />`.\\n\\nBelow, `HandlerParms` has the following type signature:\\n\\n```ts\\ntype EventHandlerParams<Datum> = {\\n  datum: Datum; // nearest Datum to event, for Series with `dataKey=key`\\n  distanceX: number; // x distance between event and Datum, in px\\n  distanceY;: number; // y distance between event and Datum, in px\\n  event: React.PointerEvent | React.FocusEvent; // the event\\n  index: number; // index of Datum in Series `data` array\\n  key: string; // `dataKey` of Series to which `Datum` belongs\\n  svgPoint: { x: number; y: number }; // event position in svg-coordinates\\n};\\n```\\n\\n| Prop name       | Signature                                     | `XYChart` support | `*Series` support |\\n| --------------- | --------------------------------------------- | ----------------- | ----------------- |\\n| `onPointerMove` | `(params: EventHandlerParams<Datum>) => void` | ‚úÖ                | ‚úÖ                |\\n| `onPointerOut`  | `(event: React.PointerEvent) => void`         | ‚úÖ                | ‚úÖ                |\\n| `onPointerUp`   | `(params: EventHandlerParams<Datum>) => void` | ‚úÖ                | ‚úÖ                |\\n| `onFocus`       | `(params: EventHandlerParams<Datum>) => void` | ‚ùå                | ‚úÖ                |\\n| `onBlur`        | `(event: React.TouchEvent) => void`           | ‚ùå                | ‚úÖ                |\\n\\n</details>\\n\\n<details>\\n\\n<summary>Annotations</summary>\\n\\n### Annotations\\n\\n`@visx/annotations` annotations are integrated into `@visx/xychart`, and allow you to annotate\\nindividual points, or x- or y-thresholds\\n\\n</details>\\n\\n## Advanced usage\\n\\n`XYChart` is implemented using modularized `React.context` layers for scales, canvas dimensions,\\ndata, events, and tooltips which enables more advanced usage than many other chart-level\\nabstractions.\\n\\nBy default `XYChart` renders all context providers if a given context is not available, but you can\\nshare context across multiple `XYChart`s to implement functionality such as linked tooltips, shared\\nthemes, or shared data.\\n\\n**Examples**\\n\\n- TODO - Custom chart background using theme and chart dimensions\\n- TODO - Linked tooltips\\n- TODO - Programmatically control tooltips\\n\\n### DataContext\\n\\nThis context provides chart canvas dimensions (`width`, `height`, and `margin`), x/y/color scales,\\nand a data registry. The data registry includes data from all child `*Series`, and x/y/color scales\\nare updated accordingly accounting for canvas dimensions.\\n\\n### ThemeContext\\n\\nThis context provides an `XYChart` theme.\\n\\n### EventEmitterContext\\n\\nThis context provides an event publishing / subscription object which can be used via the\\n`useEventEmitter` hook. `Series` and `XYChart` events, including tooltip updates, are emitted and\\nhandled with through this context.\\n\\n```tsx\\nimport { useEventEmitter, EventEmitterContext } from '@visx/xychart';\\n\\nconst eventSourceId = 'optional-source-id-filter';\\n\\n() => (\\n  <EventEmitterContext>\\n    {/** emit events */}\\n    {() => {\\n      const emit = useEventEmitter();\\n      return (\\n        <button onPointerUp={event => emit('pointerup', event, eventSourceId)}>emit event</button>\\n      );\\n    }}\\n    {/** subscribe to events */}\\n    {() => {\\n      const [clickCount, setClickCount] = useState(0);\\n      useEventEmitter('pointerUp', () => setClickCount(clickCount + 1), [eventSourceId]);\\n\\n      return <div>Pressed {clickCount} times</div>;\\n    }}\\n  </EventEmitterContext>\\n);\\n```\\n\\n### TooltipContext\\n\\nThis context provides access to `@visx/tooltip`s `useTooltip` state, including whether the tooltip\\nis visible (`tooltipOpen`), tooltlip position (`tooltipLeft`, `tooltipTop`),\\n`tooltipData: { nearestDatum, datumByKey }` described above, and functions to update context\\n(`hideTooltip`, `showTooltip`, and `updateTooltip`).\\n\\n## Roadmap üîú\\n\\n- new `*Series` types\\n  - `StackedAreaSeries`\\n  - `BoxPlotSeries`\\n  - `ViolinPlotSeries`\\n- integrate `@visx/brush`\\n- integrate `@visx/zoom` + `@visx/drag` for panning and zooming\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3Zpc3gteHljaGFydC9SZWFkbWUubWQ/ZjFkYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLHFrQ0FBc2dDLDBEQUEwRCxzQkFBc0Isd0JBQXdCLHlCQUF5QixNQUFNLHlCQUF5QixNQUFNLHlCQUF5QixNQUFNLHlCQUF5QixNQUFNLHdCQUF3QixLQUFLLHdCQUF3Qix5QkFBeUIsTUFBTSx5QkFBeUIsTUFBTSx5QkFBeUIsTUFBTSx5QkFBeUIsTUFBTSx5QkFBeUIsS0FBSywrQkFBK0IsNkJBQTZCLCtDQUErQyxJQUFJLFVBQVUsZ0JBQWdCLFVBQVUsa0JBQWtCLDJFQUEyRSxNQUFNLFdBQVcsRUFBRSxzREFBc0QsTUFBTSxZQUFZLFVBQVUsWUFBWSxVQUFVLHNEQUFzRCxNQUFNLFlBQVksVUFBVSxZQUFZLFVBQVUsbUpBQW1KLEVBQUUsMEJBQTBCLDhDQUE4QyxtREFBbUQsZ0JBQWdCLHlDQUF5QywrQkFBK0IsOENBQThDLGFBQWEsS0FBSyxhQUFhLCtDQUErQywwQkFBMEIsMEJBQTBCLDYrQ0FBNitDLFVBQVUsb29CQUFvb0Isc0JBQXNCLHNCQUFzQixVQUFVLDRCQUE0Qiw0QkFBNEIsc0RBQXNELHlDQUF5QyxvREFBb0QscUdBQXFHLGlDQUFpQywrQkFBK0IsK0NBQStDLGlDQUFpQyxpQ0FBaUMsaUNBQWlDLHVCQUF1QixtQ0FBbUMsMEJBQTBCLHVGQUF1RixHQUFHLEVBQUUsMEJBQTBCLFlBQVksazNCQUFrM0Isc2NBQXNjLFVBQVUsOERBQThELFNBQVMsOFBBQThQLGlCQUFpQiwrRUFBK0UsMkRBQTJELFNBQVMsOEZBQThGLCtCQUErQix5REFBeUQsK0RBQStELFdBQVcsYUFBYSx5Q0FBeUMsaXJFQUFpckUsdUNBQXVDLHNCQUFzQixzREFBc0QsMkNBQTJDLG1CQUFtQixPQUFPLE9BQU8sdUNBQXVDLCtDQUErQyxpREFBaUQsOEJBQThCLFFBQVEsT0FBTywyQkFBMkIsT0FBTyxPQUFPLHdEQUF3RCwyRkFBMkYsK0JBQStCLFdBQVcsYUFBYSxRQUFRLDhCQUE4QixnT0FBZ08sMkJBQTJCLHVUQUF1VCIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9kaXN0L2Nqcy5qcyEuLi92aXN4LXh5Y2hhcnQvUmVhZG1lLm1kLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIjIEB2aXN4L3h5Y2hhcnRcXG5cXG5JbiBjb250cmFzdCB0byBvdGhlciBgdmlzeGAgcGFja2FnZXMgd2hpY2ggYXJlIGxvdy1sZXZlbCwgdGhpcyBwYWNrYWdlIHNlZWtzIHRvIGFic3RyYWN0IHNvbWUgb2YgdGhlXFxuY29tcGxleGl0eSBvZiBjb21tb24gdmlzdWFsaXphdGlvbiBlbmdpbmVlcmluZywgYW5kIGV4cG9zZXMgYSAqKmhpZ2gtbGV2ZWwqKiB4LHkgKGNhcnRlc2lhblxcbmNvb3JkaW5hdGUpIGNoYXJ0IEFQSS4gSG93ZXZlciwgaXQgaXMgaW1wbGVtZW50ZWQgdXNpbmcgbW9kdWxhcml6ZWQgYFJlYWN0LmNvbnRleHRgIGxheWVycyBmb3JcXG50aGVtZSwgY2FudmFzIGRpbWVuc2lvbnMsIHgveS9jb2xvciBzY2FsZXMsIGRhdGEsIGV2ZW50cywgYW5kIHRvb2x0aXBzIHdoaWNoIGFsbG93cyBmb3IgbW9yZVxcbmV4cHJlc3Npdml0eSBhbmQgYWR2YW5jZWQgdXNlIGNhc2VzLlxcblxcbk91dCBvZiB0aGUgYm94IGl0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6XFxuXFxuLSBtYW55IGNvbW1vbiBgPCpTZXJpZXMgLz5gIHR5cGVzIChhbmltYXRlZCBvciBub3QpIHN1Y2ggYXMgbGluZXMsIGJhcnMsIGV0Yy4gKGNhbiBiZSBlYXNpbHlcXG4gIGV4dGVuZGVkIHRvIHN1cHBvcnQgbW9yZSBpbiB0aGUgZnV0dXJlKVxcbi0gYDxBeGlzIC8+YCAoYW5pbWF0ZWQgb3Igbm90KVxcbi0gYDxHcmlkIC8+YCAoYW5pbWF0ZWQgb3Igbm90KVxcbi0gYDxBbm5vdGF0aW9uIC8+YCAoYW5pbWF0ZWQgb3Igbm90KVxcbi0gYDxUb29sdGlwIC8+YFxcbi0gYHRoZW1lYGluZ1xcblxcblNlZSB0aGUgY29tcHJlaGVuc2l2ZSBBUEkgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cXG5cXG48aHIgLz5cXG5cXG4jIyBCYXNpYyB1c2FnZVxcblxcblRoZSBmb2xsb3dpbmcgaWxsdXN0cmF0ZXMgYmFzaWMgdXNhZ2UgZm9yIGFuIGFuaW1hdGVkIGxpbmUgY2hhcnQgd2l0aCBhIGJvdHRvbSBgQXhpc2AsIGBHcmlkYCwgYW5kXFxuYFRvb2x0aXBgLCB0cnkgaXQgb24gY29kZXNhbmRib3ggW2hlcmVdKHRvZG8sIHNpbXBsaWZ5IGNvZGUgYmVsb3cpOlxcblxcbmBgYHRzeFxcbmltcG9ydCB7IEFuaW1hdGVkQXhpcywgQW5pbWF0ZWRHcmlkLCBBbmltYXRlZExpbmVTZXJpZXMsIFhZQ2hhcnQgfSBmcm9tICdAdmlzeC94eWNoYXJ0JztcXG5cXG5jb25zdCBkYXRhMSA9IFtcXG4gIHsgeDogJzIwMjAtMDEtMDEnLCB5OiA1MCB9LFxcbiAgeyB4OiAnMjAyMC0wMS0wMicsIHk6IDEwIH0sXFxuICB7IHg6ICcyMDIwLTAxLTAzJywgeTogMjAgfSxcXG4gIHsgeDogJzIwMjAtMDEtMDQnLCB5OiAxMCB9LFxcbiAgeyB4OiAnMjAyMC0wMS0wNScsIHk6IDAgfSxcXG5dO1xcblxcbmNvbnN0IGRhdGEyID0gW1xcbiAgeyB4OiAnMjAyMC0wMS0wMScsIHk6IDMwIH0sXFxuICB7IHg6ICcyMDIwLTAxLTAyJywgeTogNDAgfSxcXG4gIHsgeDogJzIwMjAtMDEtMDMnLCB5OiA4MCB9LFxcbiAgeyB4OiAnMjAyMC0wMS0wNCcsIHk6IDcwIH0sXFxuICB7IHg6ICcyMDIwLTAxLTA1JywgeTogMjAgfSxcXG5dO1xcblxcbmNvbnN0IHhBY2Nlc3NvciA9IGQgPT4gZC54O1xcbmNvbnN0IHlBY2Nlc3NvciA9IGQgPT4gZC55O1xcblxcbmNvbnN0IHJlbmRlciA9ICgpID0+IChcXG4gIDxYWUNoYXJ0IGhlaWdodD17MzAwfSB4U2NhbGU9e3sgdHlwZTogJ2JhbmQnIH19IHlTY2FsZT17eyB0eXBlOiAnbGluZWFyJyB9fT5cXG4gICAgPEFuaW1hdGVkQXhpcyBvcmllbnRhdGlvbj1cXFwiYm90dG9tXFxcIiAvPlxcbiAgICA8QW5pbWF0ZWRHcmlkIGNvbHVtbnM9e2ZhbHNlfSBudW1UaWNrcz17NH0gLz5cXG4gICAgPEFuaW1hdGVkTGluZVNlcmllcyBkYXRhS2V5PVxcXCJMaW5lIDFcXFwiIGRhdGE9e2RhdGExfSB4QWNjZXNzb3I9e3hBY2Nlc3Nvcn0geUFjY2Vzc29yPXt5QWNjZXNzb3J9IC8+XFxuICAgIDxBbmltYXRlZExpbmVTZXJpZXMgZGF0YUtleT1cXFwiTGluZSAyXFxcIiBkYXRhPXtkYXRhMn0geEFjY2Vzc29yPXt4QWNjZXNzb3J9IHlBY2Nlc3Nvcj17eUFjY2Vzc29yfSAvPlxcbiAgICA8VG9vbHRpcFxcbiAgICAgIHNuYXBUb29sdGlwVG9EYXR1bVhcXG4gICAgICBzbmFwVG9vbHRpcFRvRGF0dW1ZXFxuICAgICAgc2hvd1ZlcnRpY2FsQ3Jvc3NoYWlyXFxuICAgICAgc2hvd1Nlcmllc0dseXBoc1xcbiAgICAgIHJlbmRlclRvb2x0aXA9eyh7IHRvb2x0aXBEYXRhLCBjb2xvclNjYWxlIH0pID0+IChcXG4gICAgICAgIDxkaXY+XFxuICAgICAgICAgIDxkaXYgc3R5bGU9e3sgY29sb3I6IGNvbG9yU2NhbGUodG9vbHRpcERhdGEubmVhcmVzdERhdHVtLmtleSkgfX0+XFxuICAgICAgICAgICAge3Rvb2x0aXBEYXRhLm5lYXJlc3REYXR1bS5rZXkgfHwgJ05vIGtleSd9XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICB7dG9vbHRpcERhdGEubmVhcmVzdERhdHVtLmRhdHVtLnggfHwgJ05vIGRhdGUnfVxcbiAgICAgICAgICB7JywgJ31cXG4gICAgICAgICAge3Rvb2x0aXBEYXRhLm5lYXJlc3REYXR1bS5kYXR1bS55IHx8ICdObyB2YWx1ZSd9XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICApfVxcbiAgICAvPlxcbiAgPC9YWUNoYXJ0Plxcbik7XFxuYGBgXFxuXFxuRXhwYW5kIHNlY3Rpb25zIGZvciBtb3JlLCBvciBleHBsb3JlIHRoZSBkZXRhaWxlZCBBUEkgYmVsb3cuXFxuXFxuPGRldGFpbHM+XFxuXFxuPHN1bW1hcnk+U2VyaWVzIHR5cGVzPC9zdW1tYXJ5PlxcblxcbiMjIyBTZXJpZXMgdHlwZXNcXG5cXG5UaGUgZm9sbG93aW5nIGBTZXJpZXNgIHR5cGVzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkIGFuZCB3ZSBhcmUgaGFwcHkgdG8gcmV2aWV3IG9yIGNvbnNpZGVyXFxuYWRkaXRpb25hbCBTZXJpZXMgdHlwZXMgaW4gdGhlIGZ1dHVyZS5cXG5cXG58IENvbXBvbmVudCBuYW1lICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFVzYWdlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XFxufCAoQW5pbWF0ZWQpQXJlYVNlcmllcyAgfCBDb25uZWN0IGRhdGEgcG9pbnRzIHdpdGggYSBgPHBhdGggLz5gLCB3aXRoIGEgY29sb3IgZmlsbCB0byB0aGUgemVybyBiYXNlbGluZSAgICAgICAgICAgICAgICAgICAgfCBgPEFyZWFTZXJpZXMgLz5gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcXG58IChBbmltYXRlZClCYXJTZXJpZXMgICB8IFJlbmRlciBhIGA8cmVjdCAvPmAgZm9yIGVhY2ggZGF0YSBwb2ludCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGA8QmFyU2VyaWVzIC8+YCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgKEFuaW1hdGVkKUJhckdyb3VwICAgIHwgR3JvdXAgbXVsdGlwbGUgY2hpbGQgYDxCYXJTZXJpZXMgLz5gIHZhbHVlcyB0b2dldGhlciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYDxCYXJHcm91cD48QmFyU2VyaWVzIC8+PEJhclNlcmllcyAvPi4uLjwvQmFyR3JvdXA+YCB8XFxufCAoQW5pbWF0ZWQpQmFyU3RhY2sgICAgfCBTdGFjayBtdWx0aXBsZSBjaGlsZCBgPEJhclNlcmllcyAvPmAgdmFsdWVzIHRvZ2V0aGVyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBgPEJhclN0YWNrPjxCYXJTZXJpZXMgLz48QmFyU2VyaWVzIC8+Li4uPC9CYXJTdGFjaz5gIHwgIHxcXG58IChBbmltYXRlZClHbHlwaFNlcmllcyB8IFJlbmRlciBhIGBHbHlwaGAgKGFueSBzaGFwZSwgZGVmYXVsdHMgdG8gYDxjaXJjbGUgLz5gKSBmb3IgZWFjaCBkYXRhIHBvaW50LCBlLmcuLCBhIHNjYXR0ZXIgcGxvdCB8IGA8R2x5cGhTZXJpZXMgcmVuZGVyR2x5cGg9eygpID0+IC4uLn0gLz5gICAgICAgICAgICAgfFxcbnwgKEFuaW1hdGVkKUxpbmVTZXJpZXMgIHwgQ29ubmVjdCBkYXRhIHBvaW50cyB3aXRoIGEgYDxwYXRoPmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYDxHbHlwaFNlcmllcyAvPmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxuXFxuQWxsIGBTZXJpZXNgIGhhdmUgYW5pbWF0ZWQgYW5kIG5vbi1hbmltYXRlZCB2YXJpYW50cyB0byBnaXZlIHlvdSBtb3JlIGNvbnRyb2wgb3ZlciB5b3VyIGJ1bmRsZSBzaXplLFxcbnN1cHBvcnQgbWlzc2luZyAoYG51bGxgKSBkYXRhLCBhbmQgY2FuIGJlIHJlbmRlcmVkIHZlcnRpY2FsbHkgb3IgaG9yaXpvbnRhbGx5LlxcblxcbjwvZGV0YWlscz5cXG5cXG48ZGV0YWlscz5cXG5cXG48c3VtbWFyeT5UaGVtaW5nPC9zdW1tYXJ5PlxcblxcbiMjIyBUaGVtaW5nXFxuXFxuRGVmYXVsdCBgbGlnaHRUaGVtZWAgYW5kIGBkYXJrVGhlbWVgIHRoZW1lcyBhcmUgZXhwb3J0ZWQgZnJvbSBgQHZpc3gveHljaGFydGAgYW5kIHRoZSB1dGlsaXR5XFxuYGJ1aWxkQ2hhcnRUaGVtZWAgaXMgZXhwb3J0ZWQgdG8gc3VwcG9ydCBlYXN5IGNyZWF0aW9uIG9mIGN1c3RvbSB0aGVtZXMuXFxuXFxuYGBgdHNcXG5pbXBvcnQgeyBidWlsZFRoZW1lLCBYWUNoYXJ0IH0gZnJvbSAnQHZpc3gveHljaGFydCc7XFxuaW1wb3J0IHsgVGV4dFByb3BzIGFzIFNWR1RleHRQcm9wcyB9IGZyb20gJ0B2aXN4L3RleHQvbGliL1RleHQnOyAvLyBqdXN0IGZvciB0eXBlc1xcblxcbmNvbnN0IGN1c3RvbVRoZW1lID0gYnVpbGRUaGVtZSh7XFxuICAvLyBjb2xvcnNcXG4gIGJhY2tncm91bmRDb2xvcjogc3RyaW5nOyAvLyB1c2VkIGJ5IFRvb2x0aXAsIEFubm90YXRpb25cXG4gIGNvbG9yczogc3RyaW5nW107IC8vIGNhdGVnb3JpY2FsIGNvbG9ycywgbWFwcGVkIHRvIHNlcmllcyB2aWEgYGRhdGFLZXlgc1xcblxcbiAgLy8gbGFiZWxzXFxuICBzdmdMYWJlbEJpZz86IFNWR1RleHRQcm9wcztcXG4gIHN2Z0xhYmVsU21hbGw/OiBTVkdUZXh0UHJvcHM7XFxuICBodG1sTGFiZWw/OiBIVE1MVGV4dFN0eWxlcztcXG5cXG4gIC8vIGxpbmVzXFxuICB4QXhpc0xpbmVTdHlsZXM/OiBMaW5lU3R5bGVzO1xcbiAgeUF4aXNMaW5lU3R5bGVzPzogTGluZVN0eWxlcztcXG4gIHhUaWNrTGluZVN0eWxlcz86IExpbmVTdHlsZXM7XFxuICB5VGlja0xpbmVTdHlsZXM/OiBMaW5lU3R5bGVzO1xcbiAgdGlja0xlbmd0aDogbnVtYmVyO1xcblxcbiAgLy8gZ3JpZFxcbiAgZ3JpZENvbG9yOiBzdHJpbmc7XFxuICBncmlkQ29sb3JEYXJrOiBzdHJpbmc7IC8vIHVzZWQgZm9yIGF4aXMgYmFzZWxpbmUgaWYgeC95eEF4aXNMaW5lU3R5bGVzIG5vdCBzZXRcXG4gIGdyaWRTdHlsZXM/OiBDU1NQcm9wZXJ0aWVzO1xcbn0pO1xcblxcbigpID0+IDxYWUNoYXJ0IHRoZW1lPXtjdXN0b21UaGVtZX0gLz5cXG5gYGBcXG5cXG48L2RldGFpbHM+XFxuXFxuPGRldGFpbHM+XFxuXFxuPHN1bW1hcnk+VG9vbHRpcHM8L3N1bW1hcnk+XFxuXFxuIyMjIFRvb2x0aXBzXFxuXFxuYEB2aXN4L3Rvb2x0aXBgIGBUb29sdGlwYHMgYXJlIGludGVncmF0ZWQgaW50byBgQHZpc3gveHljaGFydGAsIGFuZCBzaG91bGQgYmUgcmVuZGVyZWQgYXMgYSBjaGlsZCBvZlxcbmBYWUNoYXJ0YCAob3IgYSBjaGlsZCB3aGVyZSBgVG9vbHRpcENvbnRleHRgIGlzIHByb3ZpZGVkKS5cXG5cXG4qKmBUb29sdGlwYCBwb3NpdGlvbmluZyoqIGlzIGhhbmRsZWQgYnkgdGhlIGBUb29sdGlwYCBpdHNlbGYsIGJhc2VkIG9uIGBUb29sdGlwQ29udGV4dGAuIGBUb29sdGlwYFxcbmlzIHJlbmRlcmVkIGluc2lkZSBhIGBQb3J0YWxgLCBhdm9pZGluZyBjbGlwcGluZyBieSBwYXJlbnQgRE9NIGVsZW1lbnRzIHdpdGggaGlnaGVyIHotaW5kZXhcXG5jb250ZXh0cy4gU2VlIHRoZSBBUEkgYmVsb3cgZm9yIGEgZnVsbCBsaXN0IG9mIGBwcm9wc2AgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGJlaGF2aW9yLCBzdWNoIGFzXFxuc25hcHBpbmcgdG8gZGF0YSBwb2ludCBwb3NpdGlvbnMgYW5kIHJlbmRlcmluZyBjcm9zcy1oYWlycy5cXG5cXG4qKmBUb29sdGlwYCBjb250ZW50KiogaXMgY29udHJvbGxlZCBieSB0aGUgc3BlY2lmaWVkIGBwcm9wLnJlbmRlclRvb2x0aXBgIHdoaWNoIGhhcyBhY2Nlc3MgdG86XFxuXFxuLSBgdG9vbHRpcERhdGEubmVhcmVzdERhdHVtYCDigJMgdGhlIGdsb2JhbGx5IGNsb3Nlc3QgYERhdHVtYCwgKiphY3Jvc3MgYWxsKiogYFNlcmllc2AncyBgZGF0YUtleWBzXFxuLSBgdG9vbHRpcERhdGEuZGF0dW1CeUtleWAg4oCTIHRoZSBjbG9zZXN0IGBEYXR1bWAgKipmb3IgZWFjaCoqIGBTZXJpZXNgJ3MgYGRhdGFLZXlgOyB0aGlzIGVuYWJsZXNcXG4gIFxcXCJzaGFyZWQgdG9vbHRpcHNcXFwiIHdoZXJlIHlvdSBjYW4gcmVuZGVyIHRoZSBuZWFyZXN0IGRhdGEgcG9pbnQgZm9yIGVhY2ggYFNlcmllc2AuXFxuLSBhIHNoYXJlZCBgY29sb3JTY2FsZWAgd2hpY2ggbWFwcyBgU2VyaWVzYCdzIGBkYXRhS2V5YHMgdG8gYHRoZW1lYCBjb2xvcnNcXG5cXG48L2RldGFpbHM+XFxuXFxuPGRldGFpbHM+XFxuXFxuPHN1bW1hcnk+RXZlbnQgaGFuZGxlcnM8L3N1bW1hcnk+XFxuXFxuIyMjIEV2ZW50IGhhbmRsZXJzXFxuXFxuVGhlIGZvbGxvd2luZyBgUG9pbnRlckV2ZW50YHMgKGhhbmRsaW5nIGJvdGggYE1vdXNlRXZlbnRgcyBhbmQgYFRvdWNoRXZlbnRgcykgYXJlIGN1cnJlbnRseVxcbnN1cHBvcnRlZC4gVGhleSBtYXkgYmUgc2V0IG9uIGluZGl2aWR1YWwgYFNlcmllc2AgY29tcG9uZW50cyAoZS5nLixcXG5gPEJhclNlcmllcyBvblBvaW50ZXJNb3ZlPXsoKSA9PiAuLi59IC8+YCksIG9yIGF0IHRoZSBjaGFydCBsZXZlbCAoZS5nLixcXG5gPFhZQ2hhcnQgb25Qb2ludGVyTW92ZT17KCkgPT4ge319IC8+YCkgaW4gd2hpY2ggY2FzZSB0aGV5IGFyZSBpbnZva2VkIG9uY2UgZm9yIF9ldmVyeV8gYCpTZXJpZXNgLlxcblRvICoqZGlzYWJsZSoqIGV2ZW50IGVtaXR0aW5nIGZvciBhbnkgYFNlcmllc2Agc2V0IGA8KlNlcmllcyBlbmFibGVFdmVudHM9ZmFsc2UgLz5gLlxcblxcbkJlbG93LCBgSGFuZGxlclBhcm1zYCBoYXMgdGhlIGZvbGxvd2luZyB0eXBlIHNpZ25hdHVyZTpcXG5cXG5gYGB0c1xcbnR5cGUgRXZlbnRIYW5kbGVyUGFyYW1zPERhdHVtPiA9IHtcXG4gIGRhdHVtOiBEYXR1bTsgLy8gbmVhcmVzdCBEYXR1bSB0byBldmVudCwgZm9yIFNlcmllcyB3aXRoIGBkYXRhS2V5PWtleWBcXG4gIGRpc3RhbmNlWDogbnVtYmVyOyAvLyB4IGRpc3RhbmNlIGJldHdlZW4gZXZlbnQgYW5kIERhdHVtLCBpbiBweFxcbiAgZGlzdGFuY2VZOzogbnVtYmVyOyAvLyB5IGRpc3RhbmNlIGJldHdlZW4gZXZlbnQgYW5kIERhdHVtLCBpbiBweFxcbiAgZXZlbnQ6IFJlYWN0LlBvaW50ZXJFdmVudCB8IFJlYWN0LkZvY3VzRXZlbnQ7IC8vIHRoZSBldmVudFxcbiAgaW5kZXg6IG51bWJlcjsgLy8gaW5kZXggb2YgRGF0dW0gaW4gU2VyaWVzIGBkYXRhYCBhcnJheVxcbiAga2V5OiBzdHJpbmc7IC8vIGBkYXRhS2V5YCBvZiBTZXJpZXMgdG8gd2hpY2ggYERhdHVtYCBiZWxvbmdzXFxuICBzdmdQb2ludDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9OyAvLyBldmVudCBwb3NpdGlvbiBpbiBzdmctY29vcmRpbmF0ZXNcXG59O1xcbmBgYFxcblxcbnwgUHJvcCBuYW1lICAgICAgIHwgU2lnbmF0dXJlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYFhZQ2hhcnRgIHN1cHBvcnQgfCBgKlNlcmllc2Agc3VwcG9ydCB8XFxufCAtLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tIHxcXG58IGBvblBvaW50ZXJNb3ZlYCB8IGAocGFyYW1zOiBFdmVudEhhbmRsZXJQYXJhbXM8RGF0dW0+KSA9PiB2b2lkYCB8IOKchSAgICAgICAgICAgICAgICB8IOKchSAgICAgICAgICAgICAgICB8XFxufCBgb25Qb2ludGVyT3V0YCAgfCBgKGV2ZW50OiBSZWFjdC5Qb2ludGVyRXZlbnQpID0+IHZvaWRgICAgICAgICAgfCDinIUgICAgICAgICAgICAgICAgfCDinIUgICAgICAgICAgICAgICAgfFxcbnwgYG9uUG9pbnRlclVwYCAgIHwgYChwYXJhbXM6IEV2ZW50SGFuZGxlclBhcmFtczxEYXR1bT4pID0+IHZvaWRgIHwg4pyFICAgICAgICAgICAgICAgIHwg4pyFICAgICAgICAgICAgICAgIHxcXG58IGBvbkZvY3VzYCAgICAgICB8IGAocGFyYW1zOiBFdmVudEhhbmRsZXJQYXJhbXM8RGF0dW0+KSA9PiB2b2lkYCB8IOKdjCAgICAgICAgICAgICAgICB8IOKchSAgICAgICAgICAgICAgICB8XFxufCBgb25CbHVyYCAgICAgICAgfCBgKGV2ZW50OiBSZWFjdC5Ub3VjaEV2ZW50KSA9PiB2b2lkYCAgICAgICAgICAgfCDinYwgICAgICAgICAgICAgICAgfCDinIUgICAgICAgICAgICAgICAgfFxcblxcbjwvZGV0YWlscz5cXG5cXG48ZGV0YWlscz5cXG5cXG48c3VtbWFyeT5Bbm5vdGF0aW9uczwvc3VtbWFyeT5cXG5cXG4jIyMgQW5ub3RhdGlvbnNcXG5cXG5gQHZpc3gvYW5ub3RhdGlvbnNgIGFubm90YXRpb25zIGFyZSBpbnRlZ3JhdGVkIGludG8gYEB2aXN4L3h5Y2hhcnRgLCBhbmQgYWxsb3cgeW91IHRvIGFubm90YXRlXFxuaW5kaXZpZHVhbCBwb2ludHMsIG9yIHgtIG9yIHktdGhyZXNob2xkc1xcblxcbjwvZGV0YWlscz5cXG5cXG4jIyBBZHZhbmNlZCB1c2FnZVxcblxcbmBYWUNoYXJ0YCBpcyBpbXBsZW1lbnRlZCB1c2luZyBtb2R1bGFyaXplZCBgUmVhY3QuY29udGV4dGAgbGF5ZXJzIGZvciBzY2FsZXMsIGNhbnZhcyBkaW1lbnNpb25zLFxcbmRhdGEsIGV2ZW50cywgYW5kIHRvb2x0aXBzIHdoaWNoIGVuYWJsZXMgbW9yZSBhZHZhbmNlZCB1c2FnZSB0aGFuIG1hbnkgb3RoZXIgY2hhcnQtbGV2ZWxcXG5hYnN0cmFjdGlvbnMuXFxuXFxuQnkgZGVmYXVsdCBgWFlDaGFydGAgcmVuZGVycyBhbGwgY29udGV4dCBwcm92aWRlcnMgaWYgYSBnaXZlbiBjb250ZXh0IGlzIG5vdCBhdmFpbGFibGUsIGJ1dCB5b3UgY2FuXFxuc2hhcmUgY29udGV4dCBhY3Jvc3MgbXVsdGlwbGUgYFhZQ2hhcnRgcyB0byBpbXBsZW1lbnQgZnVuY3Rpb25hbGl0eSBzdWNoIGFzIGxpbmtlZCB0b29sdGlwcywgc2hhcmVkXFxudGhlbWVzLCBvciBzaGFyZWQgZGF0YS5cXG5cXG4qKkV4YW1wbGVzKipcXG5cXG4tIFRPRE8gLSBDdXN0b20gY2hhcnQgYmFja2dyb3VuZCB1c2luZyB0aGVtZSBhbmQgY2hhcnQgZGltZW5zaW9uc1xcbi0gVE9ETyAtIExpbmtlZCB0b29sdGlwc1xcbi0gVE9ETyAtIFByb2dyYW1tYXRpY2FsbHkgY29udHJvbCB0b29sdGlwc1xcblxcbiMjIyBEYXRhQ29udGV4dFxcblxcblRoaXMgY29udGV4dCBwcm92aWRlcyBjaGFydCBjYW52YXMgZGltZW5zaW9ucyAoYHdpZHRoYCwgYGhlaWdodGAsIGFuZCBgbWFyZ2luYCksIHgveS9jb2xvciBzY2FsZXMsXFxuYW5kIGEgZGF0YSByZWdpc3RyeS4gVGhlIGRhdGEgcmVnaXN0cnkgaW5jbHVkZXMgZGF0YSBmcm9tIGFsbCBjaGlsZCBgKlNlcmllc2AsIGFuZCB4L3kvY29sb3Igc2NhbGVzXFxuYXJlIHVwZGF0ZWQgYWNjb3JkaW5nbHkgYWNjb3VudGluZyBmb3IgY2FudmFzIGRpbWVuc2lvbnMuXFxuXFxuIyMjIFRoZW1lQ29udGV4dFxcblxcblRoaXMgY29udGV4dCBwcm92aWRlcyBhbiBgWFlDaGFydGAgdGhlbWUuXFxuXFxuIyMjIEV2ZW50RW1pdHRlckNvbnRleHRcXG5cXG5UaGlzIGNvbnRleHQgcHJvdmlkZXMgYW4gZXZlbnQgcHVibGlzaGluZyAvIHN1YnNjcmlwdGlvbiBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdmlhIHRoZVxcbmB1c2VFdmVudEVtaXR0ZXJgIGhvb2suIGBTZXJpZXNgIGFuZCBgWFlDaGFydGAgZXZlbnRzLCBpbmNsdWRpbmcgdG9vbHRpcCB1cGRhdGVzLCBhcmUgZW1pdHRlZCBhbmRcXG5oYW5kbGVkIHdpdGggdGhyb3VnaCB0aGlzIGNvbnRleHQuXFxuXFxuYGBgdHN4XFxuaW1wb3J0IHsgdXNlRXZlbnRFbWl0dGVyLCBFdmVudEVtaXR0ZXJDb250ZXh0IH0gZnJvbSAnQHZpc3gveHljaGFydCc7XFxuXFxuY29uc3QgZXZlbnRTb3VyY2VJZCA9ICdvcHRpb25hbC1zb3VyY2UtaWQtZmlsdGVyJztcXG5cXG4oKSA9PiAoXFxuICA8RXZlbnRFbWl0dGVyQ29udGV4dD5cXG4gICAgey8qKiBlbWl0IGV2ZW50cyAqL31cXG4gICAgeygpID0+IHtcXG4gICAgICBjb25zdCBlbWl0ID0gdXNlRXZlbnRFbWl0dGVyKCk7XFxuICAgICAgcmV0dXJuIChcXG4gICAgICAgIDxidXR0b24gb25Qb2ludGVyVXA9e2V2ZW50ID0+IGVtaXQoJ3BvaW50ZXJ1cCcsIGV2ZW50LCBldmVudFNvdXJjZUlkKX0+ZW1pdCBldmVudDwvYnV0dG9uPlxcbiAgICAgICk7XFxuICAgIH19XFxuICAgIHsvKiogc3Vic2NyaWJlIHRvIGV2ZW50cyAqL31cXG4gICAgeygpID0+IHtcXG4gICAgICBjb25zdCBbY2xpY2tDb3VudCwgc2V0Q2xpY2tDb3VudF0gPSB1c2VTdGF0ZSgwKTtcXG4gICAgICB1c2VFdmVudEVtaXR0ZXIoJ3BvaW50ZXJVcCcsICgpID0+IHNldENsaWNrQ291bnQoY2xpY2tDb3VudCArIDEpLCBbZXZlbnRTb3VyY2VJZF0pO1xcblxcbiAgICAgIHJldHVybiA8ZGl2PlByZXNzZWQge2NsaWNrQ291bnR9IHRpbWVzPC9kaXY+O1xcbiAgICB9fVxcbiAgPC9FdmVudEVtaXR0ZXJDb250ZXh0Plxcbik7XFxuYGBgXFxuXFxuIyMjIFRvb2x0aXBDb250ZXh0XFxuXFxuVGhpcyBjb250ZXh0IHByb3ZpZGVzIGFjY2VzcyB0byBgQHZpc3gvdG9vbHRpcGBzIGB1c2VUb29sdGlwYCBzdGF0ZSwgaW5jbHVkaW5nIHdoZXRoZXIgdGhlIHRvb2x0aXBcXG5pcyB2aXNpYmxlIChgdG9vbHRpcE9wZW5gKSwgdG9vbHRsaXAgcG9zaXRpb24gKGB0b29sdGlwTGVmdGAsIGB0b29sdGlwVG9wYCksXFxuYHRvb2x0aXBEYXRhOiB7IG5lYXJlc3REYXR1bSwgZGF0dW1CeUtleSB9YCBkZXNjcmliZWQgYWJvdmUsIGFuZCBmdW5jdGlvbnMgdG8gdXBkYXRlIGNvbnRleHRcXG4oYGhpZGVUb29sdGlwYCwgYHNob3dUb29sdGlwYCwgYW5kIGB1cGRhdGVUb29sdGlwYCkuXFxuXFxuIyMgUm9hZG1hcCDwn5ScXFxuXFxuLSBuZXcgYCpTZXJpZXNgIHR5cGVzXFxuICAtIGBTdGFja2VkQXJlYVNlcmllc2BcXG4gIC0gYEJveFBsb3RTZXJpZXNgXFxuICAtIGBWaW9saW5QbG90U2VyaWVzYFxcbi0gaW50ZWdyYXRlIGBAdmlzeC9icnVzaGBcXG4tIGludGVncmF0ZSBgQHZpc3gvem9vbWAgKyBgQHZpc3gvZHJhZ2AgZm9yIHBhbm5pbmcgYW5kIHpvb21pbmdcXG5cIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/raw-loader/dist/cjs.js!../visx-xychart/Readme.md\n");

/***/ })

})